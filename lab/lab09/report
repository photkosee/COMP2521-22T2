COMP2521 Sort Detective Lab Report
by Phot Koseekrainiramon (z5387411)
In this lab, the aim is to measure the performance of two sorting programs, without access to the code, and determine which sorting algorithm each program uses.

Experimental Design
First I would find time complexity of both sorts I've got by using ascending input as best
case and deascending input as worst case. By doing this I would know if the best and worst
cases are having the same time complexity or not.

If the runtime is totoally different each time by the same input, if that's the case then it
has to be Bogosort because of the way it works (repeatedly generates until it's sorted)

if time complexity are the same for worst and best cases then it can be both Merge or
Selection sort.

If not then leaving the rest. Then using those data from different inputs to plot a graph and
see if their actual time complexity. By doing so, things would be more clear.

Only bubble sort, insertion sort, median-of-three quicksort and randomised quicksort would
be left because they are having same time complexity. In this state, I would use more sets of
inputs in order to seperate each sort out. For insertion sort, taking deascending inputs
would be faster than ascending ones. For randomised quicksort, runtime would swing unsually.
For median-of-three quicksort, by using median, taking random inputs would make runtime swing
unlike ascending and deascending. The rest is then bubble sort.

Experimental Results
For Program A, we observed that using ascending, deascending and random inputs.

These observations indicate that the algorithm underlying the program A has the following characteristics with time complexity of O(n log n) for best case and O(n^2) for worst case.

For Program B, we observed that using ascending, deascending and random inputs.

These observations indicate that the algorithm underlying the program B has the following characteristics with same time complexity of O(n log n) for both best and worst cases.

Conclusions
On the basis of our experiments and our analysis above, we believe that

sortA implements the Naive quicksort algorithm X => insertion sort
sortB implements the Merge sorting algorithm
Appendix
Input      Initial    Number     AvgTime            AvgTime
Size       Order      of Runs    for sortA          for sortB
10000      sorted      10         0.01 sec           0.04 sec
100000     sorted      10         0.12 sec           0.27 sec
500000     sorted      10         0.58 sec           1.45 sec
1000000    sorted      10         1.16 sec           2.96 sec
10000      reverse     10         0.22 sec              -  
50000      reverse     10         4.20 sec              -
70000      reverse      5         8.15 sec              -
100000     reverse      5        16.50 sec              -
100000     reverse     10            -              0.04 sec
500000     reverse     10            -              0.26 sec
700000     reverse     10            -              1.43 sec
1000000    reverse     10            -              2.94 sec